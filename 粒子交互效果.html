<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç²’å­äº¤äº’ Pro - çŸ¢é‡è¯†åˆ«ä¸è™šæ‹Ÿå…‰æ ‡</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; cursor: none; font-family: "Microsoft YaHei", sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #fff; background: rgba(0,0,0,0.6);
            padding: 20px; border-radius: 12px; 
            border: 1px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(10px); pointer-events: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transition: opacity 0.5s;
        }
        .status-line { margin-bottom: 8px; font-size: 16px; }
        .highlight { color: #00e5ff; font-weight: bold; text-shadow: 0 0 10px rgba(0,229,255,0.5); }
        .sub-text { font-size: 12px; color: #aaa; line-height: 1.5; }

        /* æ‘„åƒå¤´åé¦ˆçª— */
        #camera-wrapper {
            position: absolute; bottom: 20px; right: 20px; 
            width: 160px; height: 120px; 
            z-index: 2; border: 2px solid #333; border-radius: 12px;
            overflow: hidden; background: #000;
            opacity: 0.7;
            transform-origin: bottom right;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #camera-wrapper.active { border-color: #00e5ff; box-shadow: 0 0 15px rgba(0,229,255,0.3); opacity: 1; transform: scale(1.1); }
        
        #video-input { 
            display: block; width: 100%; height: 100%; 
            object-fit: cover; transform: scaleX(-1);
            filter: grayscale(0.5) contrast(1.2); 
        }
        
        #output-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            transform: scaleX(-1); 
        }

        /* åŠ è½½é®ç½© */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: #00e5ff;
            transition: opacity 0.8s ease-out;
        }
        .loader {
            width: 48px; height: 48px;
            border: 3px solid #FFF; border-bottom-color: transparent;
            border-radius: 50%; display: inline-block;
            box-sizing: border-box; animation: rotation 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading-text { font-size: 14px; letter-spacing: 2px; text-transform: uppercase; color: #fff; opacity: 0.8; }
    </style>

    <!-- å¼•å…¥åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loading-screen">
        <span class="loader"></span>
        <div class="loading-text" id="loading-text">æ­£åœ¨åˆå§‹åŒ–è§†è§‰å¼•æ“...</div>
    </div>

    <div id="ui-layer">
        <div class="status-line">å½“å‰çŠ¶æ€: <span id="text-status" class="highlight">ğŸª è™šç©º (åœŸæ˜Ÿ)</span></div>
        <div class="sub-text">
            ğŸ‘‹ <b>äº”æŒ‡å¼ å¼€</b>: ç²’å­çˆ†ç‚¸<br>
            â˜ï¸ <b>æ•°å­—æ‰‹åŠ¿ (1/2/3)</b>: åˆ‡æ¢å½¢æ€<br>
            âœ¨ <b>ç§»åŠ¨æ‰‹æŒ</b>: åªæœ‰å…‰æ ‡è§¦ç¢°ç²’å­æ‰ä¼šäº§ç”Ÿæ³¢çº¹
        </div>
    </div>

    <div id="camera-wrapper">
        <video id="video-input" playsinline></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <div id="canvas-container"></div>

    <!-- 1. å‰æ™¯ç²’å­ Shader (æ–‡å­—/å›¾å½¢) -->
    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float time;
        uniform float uMorph;     
        uniform float uTransition;
        uniform float uScatter; 
        
        uniform vec3 uMousePos;
        uniform float uMouseActive;
        uniform vec3 uHandPos;
        uniform float uHandActive;

        uniform float uSceneRotation; 
        uniform float uGlobalScale;  

        attribute vec3 targetPosition;
        attribute float aSize;
        attribute float aOffset;  
        
        varying vec3 vColor;
        varying float vAlpha;
        varying float vDepth;

        mat3 rotateX(float angle) {
            float c = cos(angle);
            float s = sin(angle);
            return mat3(1, 0, 0, 0, c, -s, 0, s, c);
        }

        mat3 rotateY(float angle) {
            float c = cos(angle);
            float s = sin(angle);
            return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
        }

        mat3 rotateZ(float angle) {
            float c = cos(angle);
            float s = sin(angle);
            return mat3(c, -s, 0, s, c, 0, 0, 0, 1);
        }

        // 3D å™ªå£°å‡½æ•°æ¨¡æ‹ŸæµåŠ¨
        vec3 hash33(vec3 p) { 
            p = fract(p * vec3(.1031, .1030, .0973));
            p += dot(p, p.yxz+33.33);
            return fract((p.xxy + p.yxx)*p.zyx);
        }

        vec3 rippleEffect(vec3 p, vec3 center, float intensity, float radius) {
            float dist = distance(p, center);
            if (dist < radius) {
                float decay = 1.0 - smoothstep(0.0, radius, dist);
                float wave = sin(dist * 0.05 - time * 12.0);
                vec3 dir = normalize(p - center);
                // å¤§å¹…å‡å°åŸºç¡€æŒ¯å¹… (ç”± 60.0 é™è‡³ 15.0)ï¼Œä¿è¯æ–‡å­—æ¸…æ™°
                return dir * wave * 15.0 * decay * intensity;
            }
            return vec3(0.0);
        }

        void main() {
            float smoothProgress = smoothstep(0.0, 1.0, uMorph);
            vec3 p = mix(position, targetPosition, smoothProgress);

            // åŸºç¡€å‘¼å¸å¾‹åŠ¨ (ä»…å¾®è°ƒï¼Œä¸ç ´åæ–‡å­—ç»“æ„)
            float breath = sin(time * 2.0 + aOffset * 0.1);
            p += normalize(p) * breath * 2.0;

            // é¼ æ ‡/æ‰‹åŠ¿äº¤äº’ - è°ƒæ•´äº†å‚æ•°ï¼šå‡å°åŠå¾„(radius)å’Œå¼ºåº¦(intensity)
            // é¼ æ ‡ï¼šåŠå¾„ 300 -> 120, å¼ºåº¦ 0.8 -> 0.5
            if (uMouseActive > 0.5) p += rippleEffect(p, uMousePos, 0.5, 120.0);
            
            // æ‰‹åŠ¿ï¼šåŠå¾„ 450 -> 180, å¼ºåº¦ 2.5 -> 0.8
            // è¿™æ ·åªä¼šå½±å“å…‰æ ‡å‘¨å›´å¾ˆå°ä¸€åœˆï¼Œä¸ä¼šæ‰“ä¹±æ•´ä¸ªæ–‡å­—
            if (uHandActive > 0.5) p += rippleEffect(p, uHandPos, 0.8, 180.0);

            // çˆ†ç‚¸æ•£å¼€æ•ˆæœ
            if (uScatter > 0.0) {
                vec3 noise = hash33(p + time) - 0.5;
                vec3 dir = normalize(p); 
                float dist = uScatter * 1500.0; 
                p += dir * dist;
                p += noise * 300.0 * uScatter;
            }

            // è¿‡æ¸¡æ•ˆæœ
            if (uTransition > 0.0) {
                float scaleFactor = 1.0 + uTransition * 1.5; 
                p *= scaleFactor;
                float rotAngle = uTransition * 2.5; 
                float r1 = sin(aOffset * 12.9898);
                float r2 = cos(aOffset * 78.233);
                
                if (r1 > 0.3) p = rotateY(rotAngle * sign(r2)) * p;
                else if (r1 < -0.3) p = rotateX(rotAngle * sign(r2)) * p;
                else p = rotateZ(rotAngle * sign(r2)) * p;
                
                p = rotateY(uTransition * 0.5) * p;
            }

            // å…¨å±€æ—‹è½¬ä¸ç¼©æ”¾
            p = rotateY(uSceneRotation) * p * uGlobalScale;

            vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            float depth = -mvPosition.z;
            vDepth = depth;
            
            float sizeMod = 1.0;
            if (uHandActive > 0.5 && distance(p, uHandPos) < 400.0) sizeMod = 2.0;
            gl_PointSize = aSize * (1000.0 / depth) * (1.0 + uTransition) * sizeMod;

            vec3 cSaturn = mix(vec3(0.1, 0.4, 0.8), vec3(0.8, 0.2, 0.5), sin(aOffset + time)*0.5+0.5);
            vec3 cText = vec3(0.0, 1.0, 0.9); 
            vec3 cGold = vec3(1.0, 0.9, 0.4); 

            vec3 finalColor = mix(cSaturn, cText, smoothProgress);
            
            float interactHighlight = 0.0;
            if (uHandActive > 0.5) {
                float d = distance(p, uHandPos);
                interactHighlight = smoothstep(400.0, 0.0, d);
            }
            
            finalColor = mix(finalColor, cGold, max(interactHighlight, uScatter));
            vColor = finalColor;
            vAlpha = 1.0;
        }
    </script>

    <!-- 1. å‰æ™¯ç²’å­ Fragment Shader -->
    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor;
        varying float vAlpha;
        varying float vDepth;

        void main() {
            vec2 uv = gl_PointCoord.xy - 0.5;
            float r = length(uv);
            if(r > 0.5) discard;
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 2.0);
            float fog = smoothstep(2500.0, 800.0, vDepth); 
            gl_FragColor = vec4(vColor, vAlpha * glow * fog);
        }
    </script>


    <!-- 2. èƒŒæ™¯æ°›å›´ç²’å­ Shader (ç‹¬ç«‹ç³»ç»Ÿ) -->
    <script type="x-shader/x-vertex" id="bgVertexShader">
        uniform float time;
        uniform float uSceneRotation; // åªè·Ÿéšåœºæ™¯è½¬åŠ¨ï¼Œä¸è·Ÿéšæ‰‹åŠ¿
        attribute float aSize;
        attribute float aOffset;
        attribute vec3 aSpeed; // æ¯ä¸ªç²’å­ç‹¬ç«‹çš„ç§»åŠ¨é€Ÿåº¦
        
        varying float vAlpha;

        mat3 rotateY(float angle) {
            float c = cos(angle);
            float s = sin(angle);
            return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
        }

        void main() {
            vec3 p = position;
            
            // ç‹¬ç«‹çš„æµ®æ¸¸è¿åŠ¨ (å¸ƒæœ—è¿åŠ¨æ¨¡æ‹Ÿ)
            // ä¸å—ä»»ä½•æ‰‹åŠ¿ uniform å½±å“ï¼Œåªå—æ—¶é—´å½±å“
            // åŠ å¿«äº†æ—¶é—´ç³»æ•° (0.2 -> 0.6)ï¼Œè®©è¿åŠ¨æ›´é¢‘ç¹
            float t = time * 0.6; 
            p.x += sin(t + aOffset * 0.1) * 50.0;
            p.y += cos(t * 0.8 + aOffset * 0.2) * 50.0;
            p.z += sin(t * 0.5 + aOffset * 0.3) * 50.0;
            
            // åŠ å¿«çº¿æ€§æµåŠ¨çš„é€Ÿåº¦
            p += aSpeed * time * 25.0;
            
            // å¾ªç¯ç©ºé—´ (Wrap around)
            // è®©è·‘å‡ºå»çš„ç²’å­ä»å¦ä¸€è¾¹å›æ¥ï¼Œä¿æŒå…¨å±æœ‰ç²’å­
            if(p.x > 2500.0) p.x -= 5000.0;
            if(p.x < -2500.0) p.x += 5000.0;
            if(p.y > 1500.0) p.y -= 3000.0;
            if(p.y < -1500.0) p.y += 3000.0;
            
            // è·Ÿéšåœºæ™¯æ•´ä½“æ—‹è½¬ (ä¿æŒèƒŒæ™¯ä¸ä¸»ä½“çš„ä¸€è‡´æ€§)
            p = rotateY(uSceneRotation * 0.2) * p; // èƒŒæ™¯è½¬å¾—æ…¢ä¸€ç‚¹ï¼Œåˆ¶é€ è§†å·®

            vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            // æ·±åº¦è¡°å‡ (Depth Fade) - è¿œçš„æš—ï¼Œè¿‘çš„äº®
            float depth = -mvPosition.z;
            
            // å¤§å°éšæ·±åº¦å˜åŒ–ï¼Œå¢åŠ  3D æ„Ÿ
            gl_PointSize = aSize * (800.0 / depth);
            
            // é—ªçƒæ•ˆæœ
            float blink = 0.5 + 0.5 * sin(time * 2.0 + aOffset);
            vAlpha = blink * smoothstep(3000.0, 200.0, depth) * 0.6; // æœ€è¿œ3000å¤„å®Œå…¨é€æ˜
        }
    </script>

    <script type="x-shader/x-fragment" id="bgFragmentShader">
        varying float vAlpha;
        void main() {
            vec2 uv = gl_PointCoord.xy - 0.5;
            float r = length(uv);
            if(r > 0.5) discard;
            
            // æŸ”å’Œçš„åœ†å½¢
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 1.5);
            
            // åè“é’è‰²çš„å°˜åŸƒè‰²
            vec3 dustColor = vec3(0.4, 0.6, 0.8);
            
            gl_FragColor = vec4(dustColor, vAlpha * glow);
        }
    </script>

    <script>
        // --- 1. é…ç½®ä¸åˆå§‹åŒ– ---
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const CONFIG = {
            particleCount: isMobile ? 25000 : 60000,
            // å¢åŠ äº†èƒŒæ™¯ç²’å­æ•°é‡ï¼Œè®©ç”»é¢æ›´ä¸°å¯Œ
            bgParticleCount: isMobile ? 5000 : 12000, 
            textScale: isMobile ? 1.2 : 1.8,
            bufferSize: 5,
            canvasWidth: 2048,      
            canvasHeight: 1024
        };

        const textStatusEl = document.getElementById('text-status');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingText = document.getElementById('loading-text');

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.0004);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 8000);
        camera.position.z = 1200;

        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // --- 2. è™šæ‹Ÿå…‰æ ‡ ---
        function createCursor() {
            const geometry = new THREE.SphereGeometry(15, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, transparent: true, opacity: 0.6, depthTest: false
            });
            const cursor = new THREE.Mesh(geometry, material);
            const glowGeo = new THREE.RingGeometry(20, 25, 32);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0x00aaff, transparent: true, opacity: 0.3, side: THREE.DoubleSide, depthTest: false
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            cursor.add(glow);
            cursor.visible = false;
            scene.add(cursor);
            return { mesh: cursor, glow: glow };
        }
        const handCursor = createCursor();

        // --- 3A. å‰æ™¯ç²’å­ç³»ç»Ÿ (æ–‡å­—/äº¤äº’) ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targets = new Float32Array(CONFIG.particleCount * 3);
        const sizes = new Float32Array(CONFIG.particleCount);
        const offsets = new Float32Array(CONFIG.particleCount);

        // ç”ŸæˆåœŸæ˜Ÿ
        function generateSaturn() {
            const points = [];
            const sphereCount = Math.floor(CONFIG.particleCount * 0.5);
            for(let i=0; i<sphereCount; i++) {
                const r = 300 * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                points.push({
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                });
            }
            const ringCount = CONFIG.particleCount - sphereCount;
            for(let i=0; i<ringCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 450 + Math.random() * 400 + Math.random() * 100; 
                let px = Math.cos(angle) * dist;
                let py = (Math.random()-0.5) * 15.0; 
                let pz = Math.sin(angle) * dist;
                const tilt = 20 * Math.PI / 180;
                let y_new = py * Math.cos(tilt) - pz * Math.sin(tilt);
                let z_new = py * Math.sin(tilt) + pz * Math.cos(tilt);
                points.push({ x: px, y: y_new, z: z_new });
            }
            return points;
        }

        const saturnPoints = generateSaturn();
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const p = saturnPoints[i];
            positions[i*3] = p.x; positions[i*3+1] = p.y; positions[i*3+2] = p.z;
            targets[i*3] = p.x; targets[i*3+1] = p.y; targets[i*3+2] = p.z;
            sizes[i] = Math.random() * 2.0 + 0.5;
            offsets[i] = Math.random() * 100;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('aOffset', new THREE.BufferAttribute(offsets, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                uMorph: { value: 0 },
                uTransition: { value: 0 },
                uScatter: { value: 0 },
                uMousePos: { value: new THREE.Vector3(0, 0, 0) },
                uMouseActive: { value: 0 },
                uHandPos: { value: new THREE.Vector3(0, 0, 0) },
                uHandActive: { value: 0 },
                uSceneRotation: { value: 0 },
                uGlobalScale: { value: 1.0 }
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const pointsMesh = new THREE.Points(geometry, material);
        scene.add(pointsMesh);

        // --- 3B. èƒŒæ™¯ç²’å­ç³»ç»Ÿ (æ°›å›´/æµ®æ¸¸) ---
        // ç‹¬ç«‹çš„ç³»ç»Ÿï¼Œä¸å—å‰æ™¯ Shader é€»è¾‘å½±å“
        const bgGeometry = new THREE.BufferGeometry();
        const bgPositions = new Float32Array(CONFIG.bgParticleCount * 3);
        const bgSizes = new Float32Array(CONFIG.bgParticleCount);
        const bgOffsets = new Float32Array(CONFIG.bgParticleCount);
        const bgSpeeds = new Float32Array(CONFIG.bgParticleCount * 3);

        for(let i=0; i<CONFIG.bgParticleCount; i++) {
            // å¹¿é˜”çš„åˆ†å¸ƒèŒƒå›´ï¼Œåˆ¶é€ æ™¯æ·±
            bgPositions[i*3] = (Math.random() - 0.5) * 5000; // X
            bgPositions[i*3+1] = (Math.random() - 0.5) * 3000; // Y
            bgPositions[i*3+2] = (Math.random() - 0.5) * 4000 - 500; // Z (ååæ–¹)
            
            bgSizes[i] = Math.random() * 4.0 + 1.0;
            bgOffsets[i] = Math.random() * 100;
            
            // éšæœºå¾®å°é€Ÿåº¦
            bgSpeeds[i*3] = (Math.random() - 0.5) * 2.0; 
            bgSpeeds[i*3+1] = (Math.random() - 0.5) * 2.0;
            bgSpeeds[i*3+2] = (Math.random() - 0.5) * 2.0;
        }

        bgGeometry.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
        bgGeometry.setAttribute('aSize', new THREE.BufferAttribute(bgSizes, 1));
        bgGeometry.setAttribute('aOffset', new THREE.BufferAttribute(bgOffsets, 1));
        bgGeometry.setAttribute('aSpeed', new THREE.BufferAttribute(bgSpeeds, 3));

        const bgMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                uSceneRotation: { value: 0 }
            },
            vertexShader: document.getElementById('bgVertexShader').textContent,
            fragmentShader: document.getElementById('bgFragmentShader').textContent,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const bgMesh = new THREE.Points(bgGeometry, bgMaterial);
        scene.add(bgMesh);


        // --- 4. æ–‡æœ¬ç”Ÿæˆé€»è¾‘ ---
        function createTextPoints(text, fontSize = 200) {
            const cvs = document.createElement('canvas');
            cvs.width = CONFIG.canvasWidth; cvs.height = CONFIG.canvasHeight;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,CONFIG.canvasWidth, CONFIG.canvasHeight);
            ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = `900 ${fontSize}px "Microsoft YaHei", "Heiti SC", sans-serif`;
            ctx.fillText(text, CONFIG.canvasWidth/2, CONFIG.canvasHeight/2);
            
            const data = ctx.getImageData(0,0,CONFIG.canvasWidth, CONFIG.canvasHeight).data;
            let validPixels = [];
            const scanStep = isMobile ? 4 : 3; 
            
            for(let y=0; y<CONFIG.canvasHeight; y+=scanStep) {
                for(let x=0; x<CONFIG.canvasWidth; x+=scanStep) {
                    if(data[(y*CONFIG.canvasWidth+x)*4] > 60) {
                        const jitterX = (Math.random() - 0.5) * 3.0;
                        const jitterY = (Math.random() - 0.5) * 3.0;
                        validPixels.push({
                            x: ((x - CONFIG.canvasWidth/2) + jitterX) * CONFIG.textScale, 
                            y: (-(y - CONFIG.canvasHeight/2) + jitterY) * CONFIG.textScale,
                            z: (Math.random() - 0.5) * 50.0 
                        });
                    }
                }
            }
            const finalPoints = new Array(CONFIG.particleCount);
            if (validPixels.length > 0) {
                for (let i = validPixels.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [validPixels[i], validPixels[j]] = [validPixels[j], validPixels[i]];
                }
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const p = validPixels[i % validPixels.length];
                    finalPoints[i] = { 
                        x: p.x + (Math.random()-0.5)*2, 
                        y: p.y + (Math.random()-0.5)*2, 
                        z: p.z 
                    };
                }
            } else {
                for(let i=0; i<CONFIG.particleCount; i++) finalPoints[i] = {x:0,y:0,z:0};
            }
            return finalPoints;
        }

        const presets = {
            0: saturnPoints,
            1: createTextPoints("Hello", 350),
            2: createTextPoints("æˆ‘æ˜¯å‘±", 300),
            3: createTextPoints("æˆ‘çˆ±ä½ ä»¬", 250)
        };

        let currentTargetIndex = 0;
        let isTransitioning = false;

        function triggerTransition(index) {
            if (currentTargetIndex === index || isTransitioning) return;
            isTransitioning = true;
            currentTargetIndex = index;
            
            // ä¼˜åŒ–ï¼šåŠ å¿«èŠ‚å¥ï¼Œä½¿ç”¨ Quart æ›²çº¿è®©å¯åŠ¨æ›´å¹²è„†
            new TWEEN.Tween(material.uniforms.uTransition)
                .to({ value: 1.0 }, 500) // 1200 -> 500ms
                .easing(TWEEN.Easing.Quartic.Out)
                .onComplete(() => {
                    updateParticleTargets(index);
                    // å¿«é€Ÿå½’ä½ï¼Œå¸¦ä¸€ç‚¹å›å¼¹æ„Ÿä¼šæ›´çµåŠ¨
                    new TWEEN.Tween(material.uniforms.uTransition)
                        .to({ value: 0.0 }, 700) // 1500 -> 700ms
                        .easing(TWEEN.Easing.Cubic.Out)
                        .onComplete(() => { isTransitioning = false; })
                        .start();
                }).start();

            // å½¢æ€æ··åˆåŠ å¿«
            const targetMorph = index === 0 ? 0.0 : 1.0;
            new TWEEN.Tween(material.uniforms.uMorph)
                .to({ value: targetMorph }, 1000) // 2500 -> 1000ms
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
        }

        function updateParticleTargets(index) {
            const arr = geometry.attributes.targetPosition.array;
            const points = presets[index];
            if (!points) return;
            for(let i=0; i<CONFIG.particleCount; i++) {
                arr[i*3] = points[i].x; arr[i*3+1] = points[i].y; arr[i*3+2] = points[i].z;
            }
            geometry.attributes.targetPosition.needsUpdate = true;
        }

        // --- 5. é¼ æ ‡å¤‡ç”¨äº¤äº’ ---
        const mousePlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(mousePlane, target);
            if (target) {
                material.uniforms.uMousePos.value.copy(target);
                material.uniforms.uMouseActive.value = 1.0;
            }
        });
        document.body.addEventListener('mouseleave', () => { material.uniforms.uMouseActive.value = 0.0; });

        // --- 6. è§†è§‰ç®—æ³•ï¼šå‘é‡è§’åº¦æ³• ---
        class VectorUtils {
            static getVector(p1, p2) {
                return { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z };
            }
            static dot(v1, v2) {
                return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
            }
            static mag(v) {
                return Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
            }
            static getAngle(v1, v2) {
                const m = this.mag(v1) * this.mag(v2);
                if (m === 0) return 0;
                const cosTheta = this.dot(v1, v2) / m;
                return Math.acos(Math.max(-1, Math.min(1, cosTheta))) * (180 / Math.PI);
            }
        }

        class Stabilizer {
            constructor(limit) { this.limit = limit; this.history = []; }
            add(val) {
                this.history.push(val);
                if(this.history.length > this.limit) this.history.shift();
            }
            getStable() {
                if(this.history.length < 2) return "NONE";
                const counts = {};
                this.history.forEach(v => counts[v] = (counts[v]||0)+1);
                const threshold = this.history.length * 0.6;
                const top = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                if(counts[top] > threshold) return top;
                return "NONE"; 
            }
        }
        
        const gestureStab = new Stabilizer(CONFIG.bufferSize);
        const videoEl = document.getElementById('video-input');
        const canvasEl = document.getElementById('output-canvas');
        const ctx = canvasEl.getContext('2d');
        const cameraWrapper = document.getElementById('camera-wrapper');

        const vFOV = THREE.MathUtils.degToRad(camera.fov);
        const visibleHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
        const visibleWidth = visibleHeight * camera.aspect;

        let currentRotation = 0;
        let targetRotationSpeed = 0;
        let currentRotationSpeed = 0;
        let isHandControlling = false;

        function onResults(results) {
            if(loadingScreen.style.display !== 'none') {
                loadingText.innerText = "è§†è§‰ç³»ç»Ÿå°±ç»ª";
                setTimeout(() => {
                    loadingScreen.style.opacity = 0;
                    setTimeout(() => loadingScreen.style.display = 'none', 800);
                }, 500);
            }

            ctx.clearRect(0,0,canvasEl.width, canvasEl.height);
            ctx.drawImage(results.image, 0,0, canvasEl.width, canvasEl.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                cameraWrapper.classList.add('active');
                const lm = results.multiHandLandmarks[0];
                
                drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00e5ff', lineWidth: 2});
                drawLandmarks(ctx, lm, {color: '#ffffff', lineWidth: 1, radius: 2});

                const palm = lm[9]; 
                const handX = (0.5 - palm.x) * visibleWidth; 
                const handY = (0.5 - palm.y) * visibleHeight;
                
                const lerpFactor = 0.2;
                handCursor.mesh.position.x += (handX - handCursor.mesh.position.x) * lerpFactor;
                handCursor.mesh.position.y += (handY - handCursor.mesh.position.y) * lerpFactor;
                handCursor.mesh.visible = true;
                
                material.uniforms.uHandPos.value.copy(handCursor.mesh.position);
                material.uniforms.uHandActive.value = 1.0;
                
                isHandControlling = true;
                const offsetX = handCursor.mesh.position.x / (visibleWidth / 2); 
                targetRotationSpeed = offsetX * 0.15; 

                const wrist = lm[0];
                const isFingerStraight = (mcpIdx, pipIdx, tipIdx) => {
                    const v1 = VectorUtils.getVector(lm[mcpIdx], lm[pipIdx]);
                    const v2 = VectorUtils.getVector(lm[pipIdx], lm[tipIdx]);
                    const angle = VectorUtils.getAngle(v1, v2);
                    return angle < 30; 
                };
                
                const isThumbOpen = () => {
                   const angle = VectorUtils.getAngle(
                       VectorUtils.getVector(lm[0], lm[2]), 
                       VectorUtils.getVector(lm[2], lm[4])
                   );
                   return angle < 40;
                };

                const fIndex = isFingerStraight(5, 6, 8);
                const fMiddle = isFingerStraight(9, 10, 12);
                const fRing = isFingerStraight(13, 14, 16);
                const fPinky = isFingerStraight(17, 18, 20);
                const fThumb = isThumbOpen();

                let spread = 0;
                spread += VectorUtils.mag(VectorUtils.getVector(lm[4], lm[8]));
                spread += VectorUtils.mag(VectorUtils.getVector(lm[8], lm[12]));
                spread += VectorUtils.mag(VectorUtils.getVector(lm[12], lm[16]));
                spread += VectorUtils.mag(VectorUtils.getVector(lm[16], lm[20]));
                const isWideSpread = spread > 0.6; 

                let currentGesture = "UNKNOWN";

                if (fThumb && fIndex && fMiddle && fRing && fPinky && isWideSpread) {
                    currentGesture = "EXPLODE";
                } else if (fIndex && !fMiddle && !fRing && !fPinky) {
                    currentGesture = "ONE";
                } else if (fIndex && fMiddle && !fRing && !fPinky) {
                    currentGesture = "TWO";
                } else if (fIndex && fMiddle && fRing && !fPinky) {
                    currentGesture = "THREE";
                } else if (!fIndex && !fMiddle && !fRing && !fPinky) {
                    currentGesture = "FIST";
                } else {
                    currentGesture = "IDLE";
                }

                gestureStab.add(currentGesture);
                const stableGesture = gestureStab.getStable();

                if (stableGesture === "EXPLODE") {
                    new TWEEN.Tween(material.uniforms.uScatter)
                        .to({value: 1.0}, 150) // 200 -> 150ms çˆ†å‘æ›´å¿«
                        .easing(TWEEN.Easing.Cubic.Out)
                        .start();
                    textStatusEl.innerText = "ğŸ’¥ ç²’å­çˆ†å‘";
                    handCursor.glow.scale.set(1.5, 1.5, 1.5);
                } else {
                    new TWEEN.Tween(material.uniforms.uScatter)
                        .to({value: 0.0}, 400) // 600 -> 400ms èšé›†æ›´å¿«
                        .easing(TWEEN.Easing.Quartic.Out)
                        .start();
                    handCursor.glow.scale.set(1.0, 1.0, 1.0);

                    if (stableGesture === "ONE") {
                        triggerTransition(1); 
                        textStatusEl.innerText = "ğŸ‘‹ Hello";
                    } else if (stableGesture === "TWO") {
                        triggerTransition(2); 
                        textStatusEl.innerText = "ğŸ¸ æˆ‘æ˜¯å‘±";
                    } else if (stableGesture === "THREE") {
                        triggerTransition(3); 
                        textStatusEl.innerText = "â¤ï¸ æˆ‘çˆ±ä½ ä»¬";
                    } else if (stableGesture === "FIST") {
                         textStatusEl.innerText = "âœŠ èšé›†";
                    } else {
                        textStatusEl.innerText = "ğŸª è™šç©º (åœŸæ˜Ÿ)";
                    }
                }

            } else {
                cameraWrapper.classList.remove('active');
                material.uniforms.uHandActive.value = 0.0;
                handCursor.mesh.visible = false;
                new TWEEN.Tween(material.uniforms.uScatter).to({value: 0}, 1000).start();
                isHandControlling = false;
                targetRotationSpeed = 0;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1, 
            modelComplexity: isMobile ? 0 : 1, 
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoEl, {
            onFrame: async () => { await hands.send({image: videoEl}); },
            width: 320, height: 240
        });
        
        loadingText.innerText = "æ­£åœ¨åŠ è½½ AI æ¨¡å‹...";
        cameraUtils.start().catch(e => {
            loadingText.innerText = "æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™";
            loadingText.style.color = "red";
        });

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            
            // æ›´æ–° uniform æ—¶é—´
            material.uniforms.time.value += 0.01;
            bgMaterial.uniforms.time.value += 0.01; // æ›´æ–°èƒŒæ™¯ç²’å­æ—¶é—´

            if (isHandControlling && Math.abs(targetRotationSpeed) > 0.001) {
                // æ‰‹åŠ¿æ§åˆ¶æ—¶ï¼šè·Ÿéšæ‰‹åŠ¿æ—‹è½¬ï¼ŒåŠ å¿«å“åº” (0.1 -> 0.2)
                currentRotationSpeed += (targetRotationSpeed - currentRotationSpeed) * 0.2;
                currentRotation += currentRotationSpeed;
            } else {
                // æ‰‹åŠ¿é‡Šæ”¾åï¼šé˜»å°¼å‡é€Ÿ (0.95 -> 0.92)
                currentRotationSpeed *= 0.92; 
                currentRotation += currentRotationSpeed;

                if (currentTargetIndex === 0) {
                    if (Math.abs(currentRotationSpeed) < 0.001) {
                        currentRotation += 0.001;
                    }
                } 
                else {
                    // æ”¾å®½å›æ­£è§¦å‘æ¡ä»¶ (0.02 -> 0.05)
                    if (Math.abs(currentRotationSpeed) < 0.05) {
                        const cycle = Math.PI * 2;
                        let targetRot = Math.round(currentRotation / cycle) * cycle;
                        let diff = targetRot - currentRotation;
                        
                        // åŠ å¿«å›æ­£é€Ÿåº¦ (0.05 -> 0.12)
                        currentRotation += diff * 0.12;
                        
                        if(!isTransitioning) { 
                             // å¢åŠ ä¸€ç‚¹å›æ­£æ—¶çš„ç²’å­æ‰°åŠ¨ï¼Œè®©å®ƒçœ‹èµ·æ¥åƒæ˜¯åœ¨â€œæŠ–åŠ¨å½’ä½â€
                             const alignStress = Math.min(Math.abs(diff) * 0.8, 0.4); 
                             material.uniforms.uTransition.value += (alignStress - material.uniforms.uTransition.value) * 0.2;
                        }
                    }
                }
            }
            
            material.uniforms.uSceneRotation.value = currentRotation;
            bgMaterial.uniforms.uSceneRotation.value = currentRotation; // èƒŒæ™¯ä¹Ÿè·Ÿéšç¼“æ…¢æ—‹è½¬ï¼Œä¿æŒç©ºé—´ä¸€è‡´æ€§

            if(handCursor.mesh.visible) {
                handCursor.glow.rotation.z -= 0.05;
                const scale = 1.0 + Math.sin(time * 0.005) * 0.2;
                if(material.uniforms.uScatter.value < 0.1) {
                    handCursor.glow.scale.set(scale, scale, scale);
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
    
    <!-- å›åˆ°é¦–é¡µæŒ‰é’® -->
    <div style="position: fixed; top: 20px; left: 20px; z-index: 1000;">
        <a href="index.html" style="display: inline-block; padding: 10px 20px; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 25px; color: white; text-decoration: none; font-size: 14px; font-weight: 500; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);">
            â† å›åˆ°é¦–é¡µ
        </a>
    </div>
</body>
</html>