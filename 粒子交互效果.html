<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ç²’å­äº¤äº’ - å…¨å±€é«˜äº®æ³¢çº¹ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; cursor: none; font-family: "Microsoft YaHei", sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #fff; background: rgba(0,0,0,0.5);
            padding: 20px; border-radius: 12px; 
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px); pointer-events: none;
        }
        .status-line { margin-bottom: 8px; font-size: 16px; text-shadow: 0 0 10px rgba(255,255,255,0.8); }
        .highlight { color: #00ffff; font-weight: bold; }
        .sub-text { font-size: 12px; color: #ddd; line-height: 1.5; }

        /* æ‘„åƒå¤´åé¦ˆçª— */
        #camera-wrapper {
            position: absolute; bottom: 20px; right: 20px; 
            width: 160px; height: 120px; 
            z-index: 2; border: 2px solid #666; border-radius: 12px;
            overflow: hidden; background: #000;
            opacity: 0.6;
            transition: all 0.3s;
        }
        #camera-wrapper.active { border-color: #00ffff; opacity: 1; transform: scale(1.05); }
        
        #video-input { 
            display: block; width: 100%; height: 100%; 
            object-fit: cover; transform: scaleX(-1);
            filter: grayscale(1.0) contrast(1.5); 
        }
        
        #output-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            transform: scaleX(-1); 
        }

        /* åŠ è½½é®ç½© */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: #00ffff;
            transition: opacity 0.8s ease-out;
        }
        .loader {
            width: 48px; height: 48px;
            border: 4px solid #FFF; border-bottom-color: transparent;
            border-radius: 50%; display: inline-block;
            box-sizing: border-box; animation: rotation 1s linear infinite;
            margin-bottom: 20px;
            box-shadow: 0 0 20px #00ffff;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading-text { font-size: 16px; letter-spacing: 2px; text-shadow: 0 0 10px #00ffff; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loading-screen">
        <span class="loader"></span>
        <div class="loading-text" id="loading-text">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</div>
    </div>

    <div id="ui-layer">
        <div class="status-line">å½“å‰çŠ¶æ€: <span id="text-status" class="highlight">ğŸª è™šç©ºå½¢æ€</span></div>
        <div class="sub-text">
            ğŸ‘‹ <b>æ‰‹åŠ¿äº¤äº’</b>: ç§»åŠ¨æ‰‹æŒäº§ç”Ÿæ³¢çº¹<br>
            âœ¨ <b>å…¨å±€é«˜äº®</b>: è§†é‡å…¨å¼€ï¼Œæ— æš—åŒº<br>
        </div>
    </div>

    <div id="camera-wrapper">
        <video id="video-input" playsinline></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <div id="canvas-container"></div>

    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float time;
        uniform float uMorph;     
        uniform float uTransition;
        uniform float uScatter; 
        
        uniform vec3 uMousePos;
        uniform float uMouseActive;
        uniform vec3 uHandPos;
        uniform float uHandActive; // 0.0 æˆ– 1.0

        uniform float uSceneRotation; 
        uniform float uGlobalScale;  

        attribute vec3 targetPosition;
        attribute float aSize;
        attribute float aOffset;  
        
        varying vec3 vColor;
        varying float vAlpha;
        varying float vDepth;

        mat3 rotateX(float angle) {
            float c = cos(angle);
            float s = sin(angle);
            return mat3(1, 0, 0, 0, c, -s, 0, s, c);
        }

        mat3 rotateY(float angle) {
            float c = cos(angle);
            float s = sin(angle);
            return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
        }

        mat3 rotateZ(float angle) {
            float c = cos(angle);
            float s = sin(angle);
            return mat3(c, -s, 0, s, c, 0, 0, 0, 1);
        }

        vec3 hash33(vec3 p) { 
            p = fract(p * vec3(.1031, .1030, .0973));
            p += dot(p, p.yxz+33.33);
            return fract((p.xxy + p.yxx)*p.zyx);
        }

        // æ³¢çº¹ç‰©ç†æ•ˆæœ (ä¿ç•™)
        vec3 rippleEffect(vec3 p, vec3 center, float intensity, float radius) {
            float dist = distance(p, center);
            if (dist < radius) {
                float decay = 1.0 - smoothstep(0.0, radius, dist);
                // å¢åŠ é¢‘ç‡å’ŒæŒ¯å¹…ï¼Œè®©æ³¢çº¹æ›´æ˜æ˜¾
                float wave = sin(dist * 0.08 - time * 10.0);
                vec3 dir = normalize(p - center);
                return dir * wave * 25.0 * decay * intensity;
            }
            return vec3(0.0);
        }

        void main() {
            float smoothProgress = smoothstep(0.0, 1.0, uMorph);
            vec3 p = mix(position, targetPosition, smoothProgress);

            // å‘¼å¸å¾‹åŠ¨
            float breath = sin(time * 2.5 + aOffset * 0.1); 
            p += normalize(p) * breath * 4.0;

            // --- ç‰©ç†äº¤äº’ï¼šåªæ”¹å˜ä½ç½®ï¼Œä¸æ”¹å˜é¢œè‰² ---
            if (uMouseActive > 0.5) p += rippleEffect(p, uMousePos, 0.5, 120.0);
            if (uHandActive > 0.5) p += rippleEffect(p, uHandPos, 1.0, 250.0); // åŠå¾„250ï¼Œæ³¢çº¹èŒƒå›´é€‚ä¸­

            // çˆ†ç‚¸æ•ˆæœ
            if (uScatter > 0.0) {
                vec3 noise = hash33(p + time) - 0.5;
                vec3 dir = normalize(p); 
                float dist = uScatter * 1500.0; 
                p += dir * dist;
                p += noise * 300.0 * uScatter;
            }

            // è¿‡æ¸¡æ—‹è½¬
            if (uTransition > 0.0) {
                float scaleFactor = 1.0 + uTransition * 1.5; 
                p *= scaleFactor;
                float rotAngle = uTransition * 2.5; 
                float r1 = sin(aOffset * 12.9898);
                float r2 = cos(aOffset * 78.233);
                
                if (r1 > 0.3) p = rotateY(rotAngle * sign(r2)) * p;
                else if (r1 < -0.3) p = rotateX(rotAngle * sign(r2)) * p;
                else p = rotateZ(rotAngle * sign(r2)) * p;
                
                p = rotateY(uTransition * 0.5) * p;
            }

            // å…¨å±€æ—‹è½¬
            p = rotateY(uSceneRotation) * p * uGlobalScale;

            vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            float depth = -mvPosition.z;
            vDepth = depth;
            
            // ç²’å­å¤§å°ï¼šç•¥å¾®å¢å¤§åŸºç¡€å¤§å°ï¼Œè®©ç”»é¢æ›´æ»¡
            gl_PointSize = aSize * (1100.0 / depth) * (1.0 + uTransition);

            // --- é¢œè‰²é…ç½®ï¼šå…¨å±€å¸¸äº® ---
            // ä¿®æ”¹ç‚¹ï¼šé¢œè‰²å˜å¾—éå¸¸æ˜äº®ï¼Œä¸å†æœ‰æš—éƒ¨
            
            // åœŸæ˜Ÿæ€ï¼šæ˜äº®çš„å†°è“ + éœ“è™¹ç´«
            vec3 cSaturn = mix(vec3(0.3, 0.9, 1.0), vec3(1.0, 0.3, 0.9), sin(aOffset + time)*0.5+0.5);
            
            // æ–‡å­—æ€ï¼šé«˜äº®é’ç™½
            vec3 cText = vec3(0.6, 1.0, 0.9); 

            vec3 finalColor = mix(cSaturn, cText, smoothProgress);
            
            // å…¨å±€äº®åº¦å¢å¼ºï¼šç›´æ¥ä¹˜ç³»æ•°ï¼Œè®©é¢œè‰²"çˆ†"å‡ºæ¥
            finalColor *= 1.5; 

            // æ³¨æ„ï¼šè¿™é‡Œåˆ é™¤äº†æ‰€æœ‰åŸºäºè·ç¦»çš„é¢œè‰²æ··åˆé€»è¾‘
            // åªæœ‰çˆ†ç‚¸æ—¶ç¨å¾®å˜é‡‘ä¸€ç‚¹
            vec3 cGold = vec3(1.0, 1.0, 0.8);
            if(uScatter > 0.0) {
                finalColor = mix(finalColor, cGold, uScatter);
            }

            vColor = finalColor;
            vAlpha = 1.0;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor;
        varying float vAlpha;
        varying float vDepth;

        void main() {
            vec2 uv = gl_PointCoord.xy - 0.5;
            float r = length(uv);
            if(r > 0.5) discard;
            
            // æ ¸å¿ƒå‘å…‰ç‚¹
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 1.2); // é™ä½æŒ‡æ•°ï¼Œè®©å…‰æ™•æ›´å®ï¼Œä¸é‚£ä¹ˆè™š
            
            // ä¿®æ”¹ç‚¹ï¼šå¤§å¹…å‡å¼±é›¾æ•ˆ
            // ä¹‹å‰æ˜¯ 2500 å¤„å¼€å§‹å˜é»‘ï¼Œç°åœ¨æ¨è¿Ÿåˆ° 4000ï¼Œå¹¶ä¸”æœ€ä½äº®åº¦ä¸ä¸º0
            float fog = smoothstep(5000.0, 500.0, vDepth); 
            fog = max(fog, 0.3); // æœ€è¿œå¤„ä¹Ÿä¿ç•™ 30% äº®åº¦ï¼Œç¡®ä¿ä¸ä¼šå…¨é»‘
            
            gl_FragColor = vec4(vColor, vAlpha * glow * fog);
        }
    </script>


    <script type="x-shader/x-vertex" id="bgVertexShader">
        uniform float time;
        uniform float uSceneRotation; 
        attribute float aSize;
        attribute float aOffset;
        attribute vec3 aSpeed; 
        
        varying float vAlpha;

        mat3 rotateY(float angle) {
            float c = cos(angle);
            float s = sin(angle);
            return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
        }

        void main() {
            vec3 p = position;
            float t = time * 0.6; 
            p.x += sin(t + aOffset * 0.1) * 50.0;
            p.y += cos(t * 0.8 + aOffset * 0.2) * 50.0;
            p.z += sin(t * 0.5 + aOffset * 0.3) * 50.0;
            p += aSpeed * time * 25.0;
            
            // å¾ªç¯é€»è¾‘
            if(p.x > 2500.0) p.x -= 5000.0;
            if(p.x < -2500.0) p.x += 5000.0;
            if(p.y > 1500.0) p.y -= 3000.0;
            if(p.y < -1500.0) p.y += 3000.0;
            
            p = rotateY(uSceneRotation * 0.2) * p; 

            vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            float depth = -mvPosition.z;
            // èƒŒæ™¯ç²’å­ä¹Ÿæ”¾å¤§ä¸€ç‚¹
            gl_PointSize = aSize * (900.0 / depth);
            
            float blink = 0.5 + 0.5 * sin(time * 3.0 + aOffset);
            vAlpha = blink * smoothstep(4000.0, 200.0, depth) * 0.9; 
        }
    </script>

    <script type="x-shader/x-fragment" id="bgFragmentShader">
        varying float vAlpha;
        void main() {
            vec2 uv = gl_PointCoord.xy - 0.5;
            float r = length(uv);
            if(r > 0.5) discard;
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 1.5);
            // èƒŒæ™¯è‰²æäº®ä¸ºäº®è“è‰²
            vec3 dustColor = vec3(0.5, 0.8, 1.0);
            gl_FragColor = vec4(dustColor, vAlpha * glow);
        }
    </script>

    <script>
        // --- 1. é…ç½®ä¸åˆå§‹åŒ– ---
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const CONFIG = {
            particleCount: isMobile ? 25000 : 60000,
            bgParticleCount: isMobile ? 5000 : 15000, // å¢åŠ èƒŒæ™¯ç²’å­
            textScale: isMobile ? 1.2 : 1.8,
            bufferSize: 5,
            canvasWidth: 2048,      
            canvasHeight: 1024
        };

        const textStatusEl = document.getElementById('text-status');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingText = document.getElementById('loading-text');

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // å‡ ä¹ç§»é™¤åœºæ™¯é›¾ï¼Œä¿è¯å…¨å±é€šé€
        scene.fog = new THREE.FogExp2(0x050505, 0.0001);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 8000);
        camera.position.z = 1200;

        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // --- 2. è™šæ‹Ÿå…‰æ ‡ (å¯è§†åŒ–åœ†ç‚¹) ---
        // ä½ æåˆ°â€œå±å¹•ä¼šç”»å‡ºä¸€ä¸ªç‚¹ä»¥ç‚¹åœ†å¿ƒâ€ï¼Œè¿™é‡Œå¢å¼ºè¿™ä¸ªç‚¹çš„å¯è§†æ€§
        function createCursor() {
            // å®å¿ƒäº®ç‚¹
            const geometry = new THREE.SphereGeometry(20, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, // çº¯ç™½æ ¸å¿ƒ
                transparent: true, opacity: 0.9, depthTest: false
            });
            const cursor = new THREE.Mesh(geometry, material);
            
            // å¤–åœˆå…‰ç¯
            const glowGeo = new THREE.RingGeometry(25, 35, 32);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, // é’è‰²å…‰ç¯
                transparent: true, opacity: 0.6, side: THREE.DoubleSide, depthTest: false
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            cursor.add(glow);
            
            cursor.visible = false;
            scene.add(cursor);
            return { mesh: cursor, glow: glow };
        }
        const handCursor = createCursor();

        // --- 3. ç²’å­ç³»ç»Ÿæ„å»º ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targets = new Float32Array(CONFIG.particleCount * 3);
        const sizes = new Float32Array(CONFIG.particleCount);
        const offsets = new Float32Array(CONFIG.particleCount);

        function generateSaturn() {
            const points = [];
            const sphereCount = Math.floor(CONFIG.particleCount * 0.5);
            for(let i=0; i<sphereCount; i++) {
                const r = 300 * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                points.push({
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                });
            }
            const ringCount = CONFIG.particleCount - sphereCount;
            for(let i=0; i<ringCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 450 + Math.random() * 400 + Math.random() * 100; 
                let px = Math.cos(angle) * dist;
                let py = (Math.random()-0.5) * 15.0; 
                let pz = Math.sin(angle) * dist;
                const tilt = 20 * Math.PI / 180;
                let y_new = py * Math.cos(tilt) - pz * Math.sin(tilt);
                let z_new = py * Math.sin(tilt) + pz * Math.cos(tilt);
                points.push({ x: px, y: y_new, z: z_new });
            }
            return points;
        }

        const saturnPoints = generateSaturn();
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const p = saturnPoints[i];
            positions[i*3] = p.x; positions[i*3+1] = p.y; positions[i*3+2] = p.z;
            targets[i*3] = p.x; targets[i*3+1] = p.y; targets[i*3+2] = p.z;
            sizes[i] = Math.random() * 2.5 + 1.0; // å¢å¤§ç²’å­å°ºå¯¸èŒƒå›´
            offsets[i] = Math.random() * 100;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('aOffset', new THREE.BufferAttribute(offsets, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                uMorph: { value: 0 },
                uTransition: { value: 0 },
                uScatter: { value: 0 },
                uMousePos: { value: new THREE.Vector3(0, 0, 0) },
                uMouseActive: { value: 0 },
                uHandPos: { value: new THREE.Vector3(0, 0, 0) },
                uHandActive: { value: 0 },
                uSceneRotation: { value: 0 },
                uGlobalScale: { value: 1.0 }
            },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const pointsMesh = new THREE.Points(geometry, material);
        scene.add(pointsMesh);

        // --- èƒŒæ™¯ç²’å­ ---
        const bgGeometry = new THREE.BufferGeometry();
        const bgPositions = new Float32Array(CONFIG.bgParticleCount * 3);
        const bgSizes = new Float32Array(CONFIG.bgParticleCount);
        const bgOffsets = new Float32Array(CONFIG.bgParticleCount);
        const bgSpeeds = new Float32Array(CONFIG.bgParticleCount * 3);

        for(let i=0; i<CONFIG.bgParticleCount; i++) {
            bgPositions[i*3] = (Math.random() - 0.5) * 5000;
            bgPositions[i*3+1] = (Math.random() - 0.5) * 3000;
            bgPositions[i*3+2] = (Math.random() - 0.5) * 4000 - 500;
            
            bgSizes[i] = Math.random() * 5.0 + 1.5; // èƒŒæ™¯ç²’å­ä¹Ÿæ›´å¤§
            bgOffsets[i] = Math.random() * 100;
            
            bgSpeeds[i*3] = (Math.random() - 0.5) * 2.0; 
            bgSpeeds[i*3+1] = (Math.random() - 0.5) * 2.0;
            bgSpeeds[i*3+2] = (Math.random() - 0.5) * 2.0;
        }

        bgGeometry.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
        bgGeometry.setAttribute('aSize', new THREE.BufferAttribute(bgSizes, 1));
        bgGeometry.setAttribute('aOffset', new THREE.BufferAttribute(bgOffsets, 1));
        bgGeometry.setAttribute('aSpeed', new THREE.BufferAttribute(bgSpeeds, 3));

        const bgMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                uSceneRotation: { value: 0 }
            },
            vertexShader: document.getElementById('bgVertexShader').textContent,
            fragmentShader: document.getElementById('bgFragmentShader').textContent,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const bgMesh = new THREE.Points(bgGeometry, bgMaterial);
        scene.add(bgMesh);


        // --- æ–‡æœ¬ç”Ÿæˆ ---
        function createTextPoints(text, fontSize = 200) {
            const cvs = document.createElement('canvas');
            cvs.width = CONFIG.canvasWidth; cvs.height = CONFIG.canvasHeight;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,CONFIG.canvasWidth, CONFIG.canvasHeight);
            ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = `900 ${fontSize}px "Microsoft YaHei", "Heiti SC", sans-serif`;
            ctx.fillText(text, CONFIG.canvasWidth/2, CONFIG.canvasHeight/2);
            
            const data = ctx.getImageData(0,0,CONFIG.canvasWidth, CONFIG.canvasHeight).data;
            let validPixels = [];
            const scanStep = isMobile ? 4 : 3; 
            
            for(let y=0; y<CONFIG.canvasHeight; y+=scanStep) {
                for(let x=0; x<CONFIG.canvasWidth; x+=scanStep) {
                    if(data[(y*CONFIG.canvasWidth+x)*4] > 60) {
                        const jitterX = (Math.random() - 0.5) * 3.0;
                        const jitterY = (Math.random() - 0.5) * 3.0;
                        validPixels.push({
                            x: ((x - CONFIG.canvasWidth/2) + jitterX) * CONFIG.textScale, 
                            y: (-(y - CONFIG.canvasHeight/2) + jitterY) * CONFIG.textScale,
                            z: (Math.random() - 0.5) * 50.0 
                        });
                    }
                }
            }
            const finalPoints = new Array(CONFIG.particleCount);
            if (validPixels.length > 0) {
                for (let i = validPixels.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [validPixels[i], validPixels[j]] = [validPixels[j], validPixels[i]];
                }
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const p = validPixels[i % validPixels.length];
                    finalPoints[i] = { 
                        x: p.x + (Math.random()-0.5)*2, 
                        y: p.y + (Math.random()-0.5)*2, 
                        z: p.z 
                    };
                }
            } else {
                for(let i=0; i<CONFIG.particleCount; i++) finalPoints[i] = {x:0,y:0,z:0};
            }
            return finalPoints;
        }

        const presets = {
            0: saturnPoints,
            1: createTextPoints("Hello", 350),
            2: createTextPoints("æˆ‘æ˜¯å‘±", 300),
            3: createTextPoints("æˆ‘çˆ±ä½ ä»¬", 250)
        };

        let currentTargetIndex = 0;
        let isTransitioning = false;

        function triggerTransition(index) {
            if (currentTargetIndex === index || isTransitioning) return;
            isTransitioning = true;
            currentTargetIndex = index;
            
            new TWEEN.Tween(material.uniforms.uTransition)
                .to({ value: 1.0 }, 500)
                .easing(TWEEN.Easing.Quartic.Out)
                .onComplete(() => {
                    updateParticleTargets(index);
                    new TWEEN.Tween(material.uniforms.uTransition)
                        .to({ value: 0.0 }, 700)
                        .easing(TWEEN.Easing.Cubic.Out)
                        .onComplete(() => { isTransitioning = false; })
                        .start();
                }).start();

            const targetMorph = index === 0 ? 0.0 : 1.0;
            new TWEEN.Tween(material.uniforms.uMorph)
                .to({ value: targetMorph }, 1000)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
        }

        function updateParticleTargets(index) {
            const arr = geometry.attributes.targetPosition.array;
            const points = presets[index];
            if (!points) return;
            for(let i=0; i<CONFIG.particleCount; i++) {
                arr[i*3] = points[i].x; arr[i*3+1] = points[i].y; arr[i*3+2] = points[i].z;
            }
            geometry.attributes.targetPosition.needsUpdate = true;
        }

        // --- äº¤äº’è¾…åŠ©ç±» ---
        class VectorUtils {
            static getVector(p1, p2) { return { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z }; }
            static dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z; }
            static mag(v) { return Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z); }
            static getAngle(v1, v2) {
                const m = this.mag(v1) * this.mag(v2);
                if (m === 0) return 0;
                return Math.acos(Math.max(-1, Math.min(1, this.dot(v1, v2) / m))) * (180 / Math.PI);
            }
        }

        class Stabilizer {
            constructor(limit) { this.limit = limit; this.history = []; }
            add(val) {
                this.history.push(val);
                if(this.history.length > this.limit) this.history.shift();
            }
            getStable() {
                if(this.history.length < 2) return "NONE";
                const counts = {};
                this.history.forEach(v => counts[v] = (counts[v]||0)+1);
                const threshold = this.history.length * 0.6;
                const top = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
                return counts[top] > threshold ? top : "NONE"; 
            }
        }
        
        const gestureStab = new Stabilizer(CONFIG.bufferSize);
        const videoEl = document.getElementById('video-input');
        const canvasEl = document.getElementById('output-canvas');
        const ctx = canvasEl.getContext('2d');
        const cameraWrapper = document.getElementById('camera-wrapper');

        const vFOV = THREE.MathUtils.degToRad(camera.fov);
        const visibleHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
        const visibleWidth = visibleHeight * camera.aspect;

        let currentRotation = 0;
        let targetRotationSpeed = 0;
        let currentRotationSpeed = 0;
        let isHandControlling = false;

        function onResults(results) {
            if(loadingScreen.style.display !== 'none') {
                loadingText.innerText = "è§†è§‰ç³»ç»Ÿå°±ç»ª";
                setTimeout(() => {
                    loadingScreen.style.opacity = 0;
                    setTimeout(() => loadingScreen.style.display = 'none', 800);
                }, 500);
            }

            ctx.clearRect(0,0,canvasEl.width, canvasEl.height);
            ctx.drawImage(results.image, 0,0, canvasEl.width, canvasEl.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                cameraWrapper.classList.add('active');
                const lm = results.multiHandLandmarks[0];
                
                drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00ffff', lineWidth: 2});
                drawLandmarks(ctx, lm, {color: '#ffffff', lineWidth: 1, radius: 2});

                const palm = lm[9]; 
                const handX = (0.5 - palm.x) * visibleWidth; 
                const handY = (0.5 - palm.y) * visibleHeight;
                
                const lerpFactor = 0.2;
                handCursor.mesh.position.x += (handX - handCursor.mesh.position.x) * lerpFactor;
                handCursor.mesh.position.y += (handY - handCursor.mesh.position.y) * lerpFactor;
                handCursor.mesh.visible = true; // æ˜¾ç¤ºåœ†ç‚¹
                
                material.uniforms.uHandPos.value.copy(handCursor.mesh.position);
                material.uniforms.uHandActive.value = 1.0;
                
                isHandControlling = true;
                const offsetX = handCursor.mesh.position.x / (visibleWidth / 2); 
                
                // æä½è½¬é€Ÿï¼Œä¿æŒå¹³æ»‘
                targetRotationSpeed = offsetX * 0.025; 

                // æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
                const isFingerStraight = (mcpIdx, pipIdx, tipIdx) => {
                    const v1 = VectorUtils.getVector(lm[mcpIdx], lm[pipIdx]);
                    const v2 = VectorUtils.getVector(lm[pipIdx], lm[tipIdx]);
                    return VectorUtils.getAngle(v1, v2) < 30; 
                };
                
                const fIndex = isFingerStraight(5, 6, 8);
                const fMiddle = isFingerStraight(9, 10, 12);
                const fRing = isFingerStraight(13, 14, 16);
                const fPinky = isFingerStraight(17, 18, 20);
                
                const spread = VectorUtils.mag(VectorUtils.getVector(lm[4], lm[8])) + 
                               VectorUtils.mag(VectorUtils.getVector(lm[8], lm[12])) +
                               VectorUtils.mag(VectorUtils.getVector(lm[12], lm[16])) +
                               VectorUtils.mag(VectorUtils.getVector(lm[16], lm[20]));
                const isWideSpread = spread > 0.6; 

                let currentGesture = "IDLE";
                if (fIndex && fMiddle && fRing && fPinky && isWideSpread) currentGesture = "EXPLODE";
                else if (fIndex && !fMiddle && !fRing && !fPinky) currentGesture = "ONE";
                else if (fIndex && fMiddle && !fRing && !fPinky) currentGesture = "TWO";
                else if (fIndex && fMiddle && fRing && !fPinky) currentGesture = "THREE";
                else if (!fIndex && !fMiddle && !fRing && !fPinky) currentGesture = "FIST";

                gestureStab.add(currentGesture);
                const stableGesture = gestureStab.getStable();

                if (stableGesture === "EXPLODE") {
                    new TWEEN.Tween(material.uniforms.uScatter).to({value: 1.0}, 150).easing(TWEEN.Easing.Cubic.Out).start();
                    textStatusEl.innerText = "ğŸ’¥ ç²’å­çˆ†å‘";
                    handCursor.glow.scale.set(1.5, 1.5, 1.5);
                } else {
                    new TWEEN.Tween(material.uniforms.uScatter).to({value: 0.0}, 400).easing(TWEEN.Easing.Quartic.Out).start();
                    handCursor.glow.scale.set(1.0, 1.0, 1.0);

                    if (stableGesture === "ONE") { triggerTransition(1); textStatusEl.innerText = "ğŸ‘‹ Hello"; }
                    else if (stableGesture === "TWO") { triggerTransition(2); textStatusEl.innerText = "ğŸ¸ æˆ‘æ˜¯å‘±"; }
                    else if (stableGesture === "THREE") { triggerTransition(3); textStatusEl.innerText = "â¤ï¸ æˆ‘çˆ±ä½ ä»¬"; }
                    else if (stableGesture === "FIST") textStatusEl.innerText = "âœŠ èšé›†";
                    else textStatusEl.innerText = "ğŸª è™šç©ºå½¢æ€";
                }
            } else {
                cameraWrapper.classList.remove('active');
                material.uniforms.uHandActive.value = 0.0;
                handCursor.mesh.visible = false;
                new TWEEN.Tween(material.uniforms.uScatter).to({value: 0}, 1000).start();
                isHandControlling = false;
                targetRotationSpeed = 0;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: isMobile ? 0 : 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoEl, { onFrame: async () => { await hands.send({image: videoEl}); }, width: 320, height: 240 });
        cameraUtils.start();

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            
            material.uniforms.time.value += 0.01;
            bgMaterial.uniforms.time.value += 0.01;

            if (isHandControlling && Math.abs(targetRotationSpeed) > 0.001) {
                currentRotationSpeed += (targetRotationSpeed - currentRotationSpeed) * 0.15;
                currentRotation += currentRotationSpeed;
            } else {
                currentRotationSpeed *= 0.92; 
                currentRotation += currentRotationSpeed;
                if (currentTargetIndex === 0 && Math.abs(currentRotationSpeed) < 0.001) currentRotation += 0.001;
                else if (Math.abs(currentRotationSpeed) < 0.05) {
                     const cycle = Math.PI * 2;
                     let diff = (Math.round(currentRotation / cycle) * cycle) - currentRotation;
                     currentRotation += diff * 0.12;
                }
            }
            
            material.uniforms.uSceneRotation.value = currentRotation;
            bgMaterial.uniforms.uSceneRotation.value = currentRotation;

            if(handCursor.mesh.visible) {
                handCursor.glow.rotation.z -= 0.05;
                const scale = 1.0 + Math.sin(time * 0.01) * 0.15;
                handCursor.glow.scale.set(scale, scale, scale);
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    
    <div style="position: fixed; top: 20px; left: 20px; z-index: 1000;">
        <a href="index.html" style="display: inline-block; padding: 10px 20px; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 25px; color: white; text-decoration: none; font-size: 14px; font-weight: 500; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);">
            â† å›åˆ°é¦–é¡µ
        </a>
    </div>
</body>
</html>